import re
import os
import json
from pathlib import Path

from twisted.internet import reactor
from quarry.net.server import ServerFactory, ServerProtocol
from quarry.net.protocol import ProtocolError

from honeylake_common import setup_logging, save_exploit_sample, get_env_int, get_env_str

logger = setup_logging(__name__)

SAMPLES_DIR = Path('/samples')

# Server configuration from environment variables
LISTEN_HOST = get_env_str('LISTEN_HOST', '0.0.0.0')
LISTEN_PORT = get_env_int('LISTEN_PORT', 25565)
SERVER_MOTD = get_env_str('SERVER_MOTD', 'A Minecraft Server')
SERVER_VERSION = get_env_str('SERVER_VERSION', '1.18.0')
PROTOCOL_VERSION = get_env_int('PROTOCOL_VERSION', 757) # https://minecraft.fandom.com/wiki/Protocol_version#Java_Edition_2
MAX_PLAYERS = get_env_int('MAX_PLAYERS', 20)
ONLINE_PLAYERS = get_env_int('ONLINE_PLAYERS', 3)
WHITELIST_ENABLED = get_env_str('WHITELIST_ENABLED', 'true').lower() == 'true'

# from https://github.com/back2root/log4shell-rex
JNDI_PATTERN = re.compile(r'(?im)(?:^|[\n]).*?(?:[\x24]|%(?:25%?)*24|\\u?0*(?:44|24))(?:[\x7b]|%(?:25%?)*7b|\\u?0*(?:7b|173))[^\n]*?((?:j|%(?:25%?)*(?:4a|6a)|\\u?0*(?:112|6a|4a|152))[^\n]*?(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))[^\n]*?(?:[\x3a]|%(?:25%?)*3a|\\u?0*(?:72|3a))[^\n]*?((?:l|%(?:25%?)*(?:4c|6c)|\\u?0*(?:154|114|6c|4c))[^\n]*?(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:a|%(?:25%?)*(?:41|61)|\\u?0*(?:101|61|41|141))[^\n]*?(?:p|%(?:25%?)*(?:50|70)|\\u?0*(?:70|50|160|120))(?:[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163)))?|(?:r|%(?:25%?)*(?:52|72)|\\u?0*(?:122|72|52|162))[^\n]*?(?:m|%(?:25%?)*(?:4d|6d)|\\u?0*(?:4d|155|115|6d))[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))|(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))|(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))|(?:[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))){2}[^\n]*?(?:o|%(?:25%?)*(?:4f|6f)|\\u?0*(?:6f|4f|157|117))[^\n]*?(?:p|%(?:25%?)*(?:50|70)|\\u?0*(?:70|50|160|120))|(?:c|%(?:25%?)*(?:43|63)|\\u?0*(?:143|103|63|43))[^\n]*?(?:o|%(?:25%?)*(?:4f|6f)|\\u?0*(?:6f|4f|157|117))[^\n]*?(?:r|%(?:25%?)*(?:52|72)|\\u?0*(?:122|72|52|162))[^\n]*?(?:b|%(?:25%?)*(?:42|62)|\\u?0*(?:102|62|42|142))[^\n]*?(?:a|%(?:25%?)*(?:41|61)|\\u?0*(?:101|61|41|141))|(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))|(?:h|%(?:25%?)*(?:48|68)|\\u?0*(?:110|68|48|150))(?:[^\n]*?(?:t|%(?:25%?)*(?:54|74)|\\u?0*(?:124|74|54|164))){2}[^\n]*?(?:p|%(?:25%?)*(?:50|70)|\\u?0*(?:70|50|160|120))(?:[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163)))?)[^\n]*?(?:[\x3a]|%(?:25%?)*3a|\\u?0*(?:72|3a))|(?:b|%(?:25%?)*(?:42|62)|\\u?0*(?:102|62|42|142))[^\n]*?(?:a|%(?:25%?)*(?:41|61)|\\u?0*(?:101|61|41|141))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))[^\n]*?(?:e|%(?:25%?)*(?:45|65)|\\u?0*(?:45|145|105|65))[^\n]*?(?:[\x3a]|%(?:25%?)*3a|\\u?0*(?:72|3a))(JH[s-v]|[\x2b\x2f-9A-Za-z][CSiy]R7|[\x2b\x2f-9A-Za-z]{2}[048AEIMQUYcgkosw]ke[\x2b\x2f-9w-z]))')


class Log4ShellProtocol(ServerProtocol):
    # In case clients attempt to join with a different version
    def protocol_error(self, err):
        logger.debug(f"Protocol error from {self.transport.getPeer().host}: {err}")
        self.close()

    def detect_jndi(self, text, context=""):
        if not isinstance(text, str):
            return

        match = JNDI_PATTERN.search(text)
        if match:
            client_addr = self.transport.getPeer()

            logger.warning(
                f"[JNDI LOOKUP DETECTED] Client: {client_addr.host}:{client_addr.port} | Context: {context}"
            )

            # Prepare payload information
            payload_info = f"Context: {context}\nFull Payload: {text}\nMatched Pattern: {match.group(0)}"
            if match.groups():
                payload_info += f"\nCaptured Groups: {match.groups()}"

            # Extract the matched JNDI pattern for analysis
            extracted_payloads = [match.group(0)]
            if match.groups():
                extracted_payloads.extend([g for g in match.groups() if g])

            # Save using standardized JSON format
            sample_path = save_exploit_sample(
                cve="CVE-2021-44228",
                client_ip=client_addr.host,
                client_port=client_addr.port,
                headers={},  # No headers for Minecraft protocol!!!!
                body=payload_info.encode('utf-8'),
                samples_dir=SAMPLES_DIR,
                honeypot="minecraft-log4shell",
                protocol="Minecraft",
                extracted_payloads=extracted_payloads,
                attack_type="log4shell_jndi",
                confidence="high",
                context=context
            )

            logger.info(f"Attack payload saved to {sample_path}")

    # Craft a fake response
    def packet_status_request(self, _buff):
        status = {
            "version": {
                "name": self.factory.minecraft_version,
                "protocol": self.factory.protocol_version
            },
            "players": {
                "max": self.factory.max_players,
                "online": ONLINE_PLAYERS,
                "sample": []
            },
            "description": self.factory.motd
        }
        self.send_packet("status_response", self.buff_type.pack_string(json.dumps(status)))

    # Detect in server address
    def packet_handshake(self, buff):
        protocol_version = buff.unpack_varint()
        server_addr = buff.unpack_string()
        server_port = buff.unpack('H')
        next_state = buff.unpack_varint()

        logger.info(f"Handshake from {self.transport.getPeer().host}: protocol={protocol_version}, server_addr={server_addr}, server_port={server_port}, next_state={next_state}")
        self.detect_jndi(server_addr, context="handshake_server_address")

        self.client_protocol_version = protocol_version

        # Handle status requests
        if next_state == 1:
            self.protocol_mode = "status"
            self.protocol_version = self.factory.protocol_version

        # Handle login attempts
        elif next_state == 2:
            if protocol_version != self.factory.protocol_version:
                logger.info(f"Rejecting incompatible protocol {protocol_version} (expected {self.factory.protocol_version})")
                if protocol_version < self.factory.protocol_version:
                    disconnect_msg = {"text": f"Outdated client! Please use {self.factory.minecraft_version}"}
                else:
                    disconnect_msg = {"text": f"Outdated server! I'm still on {self.factory.minecraft_version}"}

                self.send_packet("login_disconnect", self.buff_type.pack_chat(json.dumps(disconnect_msg)))
                self.close()
                return

            self.protocol_mode = "login"
            self.protocol_version = protocol_version

    # Detect in username then kick
    def packet_login_start(self, buff):
        username = buff.unpack_string()
        client_addr = self.transport.getPeer()
        logger.info(f"Login attempt from {client_addr.host}: username={username}")
        self.detect_jndi(username, context="login_username")

        # Kick with appropriate message based on whitelist configuration
        if WHITELIST_ENABLED:
            disconnect_msg = {"text": "You are not whitelisted on this server!"}
            self.send_packet("login_disconnect", self.buff_type.pack_chat(json.dumps(disconnect_msg)))
            self.close()
        else:
            # Fall back to IOException for non-whitelist mode
            self.close("Internal Exception: java.io.IOException: An existing connection was forcibly closed by the remote host")


def main():
    factory = ServerFactory()
    factory.protocol = Log4ShellProtocol
    factory.motd = SERVER_MOTD
    factory.protocol_version = PROTOCOL_VERSION
    factory.minecraft_version = SERVER_VERSION
    factory.max_players = MAX_PLAYERS
    factory.online_mode = False

    logger.info(f"Starting CVE-2021-44228 Honeypot on {LISTEN_HOST}:{LISTEN_PORT}")
    logger.info(f"-> Advertising as Minecraft version {SERVER_VERSION} (protocol {PROTOCOL_VERSION})")
    logger.info(f"-> MOTD: {SERVER_MOTD}")
    logger.info(f"-> Max players: {MAX_PLAYERS}")
    logger.info(f"-> Online players: {ONLINE_PLAYERS}")
    logger.info(f"-> Whitelist: {'Enabled' if WHITELIST_ENABLED else 'Disabled'}")

    factory.listen(LISTEN_HOST, LISTEN_PORT)
    reactor.run()


if __name__ == '__main__':
    main()
