import re
import logging
import os
import json
from datetime import datetime
from pathlib import Path

from twisted.internet import reactor
from quarry.net.server import ServerFactory, ServerProtocol

logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)

SAMPLES_DIR = Path('/samples')
SAMPLES_DIR.mkdir(exist_ok=True)

# Server configuration from environment variables
LISTEN_HOST = os.getenv('LISTEN_HOST', '0.0.0.0')
LISTEN_PORT = int(os.getenv('LISTEN_PORT', '25565'))
SERVER_MOTD = os.getenv('SERVER_MOTD', 'A Minecraft Server')
SERVER_VERSION = os.getenv('SERVER_VERSION', '1.18.0')
PROTOCOL_VERSION = int(os.getenv('PROTOCOL_VERSION', '757')) # https://minecraft.fandom.com/wiki/Protocol_version#Java_Edition_2
MAX_PLAYERS = int(os.getenv('MAX_PLAYERS', '20'))
ONLINE_PLAYERS = int(os.getenv('ONLINE_PLAYERS', '3'))

# from https://github.com/back2root/log4shell-rex
JNDI_PATTERN = re.compile(r'(?im)(?:^|[\n]).*?(?:[\x24]|%(?:25%?)*24|\\u?0*(?:44|24))(?:[\x7b]|%(?:25%?)*7b|\\u?0*(?:7b|173))[^\n]*?((?:j|%(?:25%?)*(?:4a|6a)|\\u?0*(?:112|6a|4a|152))[^\n]*?(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))[^\n]*?(?:[\x3a]|%(?:25%?)*3a|\\u?0*(?:72|3a))[^\n]*?((?:l|%(?:25%?)*(?:4c|6c)|\\u?0*(?:154|114|6c|4c))[^\n]*?(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:a|%(?:25%?)*(?:41|61)|\\u?0*(?:101|61|41|141))[^\n]*?(?:p|%(?:25%?)*(?:50|70)|\\u?0*(?:70|50|160|120))(?:[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163)))?|(?:r|%(?:25%?)*(?:52|72)|\\u?0*(?:122|72|52|162))[^\n]*?(?:m|%(?:25%?)*(?:4d|6d)|\\u?0*(?:4d|155|115|6d))[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))|(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))|(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))|(?:[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))){2}[^\n]*?(?:o|%(?:25%?)*(?:4f|6f)|\\u?0*(?:6f|4f|157|117))[^\n]*?(?:p|%(?:25%?)*(?:50|70)|\\u?0*(?:70|50|160|120))|(?:c|%(?:25%?)*(?:43|63)|\\u?0*(?:143|103|63|43))[^\n]*?(?:o|%(?:25%?)*(?:4f|6f)|\\u?0*(?:6f|4f|157|117))[^\n]*?(?:r|%(?:25%?)*(?:52|72)|\\u?0*(?:122|72|52|162))[^\n]*?(?:b|%(?:25%?)*(?:42|62)|\\u?0*(?:102|62|42|142))[^\n]*?(?:a|%(?:25%?)*(?:41|61)|\\u?0*(?:101|61|41|141))|(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))|(?:h|%(?:25%?)*(?:48|68)|\\u?0*(?:110|68|48|150))(?:[^\n]*?(?:t|%(?:25%?)*(?:54|74)|\\u?0*(?:124|74|54|164))){2}[^\n]*?(?:p|%(?:25%?)*(?:50|70)|\\u?0*(?:70|50|160|120))(?:[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163)))?)[^\n]*?(?:[\x3a]|%(?:25%?)*3a|\\u?0*(?:72|3a))|(?:b|%(?:25%?)*(?:42|62)|\\u?0*(?:102|62|42|142))[^\n]*?(?:a|%(?:25%?)*(?:41|61)|\\u?0*(?:101|61|41|141))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))[^\n]*?(?:e|%(?:25%?)*(?:45|65)|\\u?0*(?:45|145|105|65))[^\n]*?(?:[\x3a]|%(?:25%?)*3a|\\u?0*(?:72|3a))(JH[s-v]|[\x2b\x2f-9A-Za-z][CSiy]R7|[\x2b\x2f-9A-Za-z]{2}[048AEIMQUYcgkosw]ke[\x2b\x2f-9w-z]))')


class Log4ShellProtocol(ServerProtocol):
    def detect_jndi(self, text, context=""):
        if not isinstance(text, str):
            return

        match = JNDI_PATTERN.search(text)
        if match:
            timestamp = datetime.now().isoformat()
            client_addr = self.transport.getPeer()

            logger.warning(
                f"[JNDI LOOKUP DETECTED] Client: {client_addr.host}:{client_addr.port} | "
            )

            # Save to samples directory
            filename = f"log4shell_{timestamp.replace(':', '-')}_{client_addr.host}.txt"
            sample_path = SAMPLES_DIR / filename

            with open(sample_path, 'w') as f:
                f.write(f"Timestamp: {timestamp}\n")
                f.write(f"Client IP: {client_addr.host}\n")
                f.write(f"Client Port: {client_addr.port}\n")
                f.write(f"Context: {context}\n")
                f.write(f"Full Payload: {text}\n")
                f.write(f"Matched Pattern: {match.group(0)}\n")
                if match.groups():
                    f.write(f"Captured Groups: {match.groups()}\n")

            logger.info(f"Attack payload saved to {sample_path}")

    # Craft a fake response
    def packet_status_request(self, _buff):
        status = {
            "version": {
                "name": self.factory.minecraft_version,
                "protocol": self.factory.protocol_version
            },
            "players": {
                "max": self.factory.max_players,
                "online": ONLINE_PLAYERS,
                "sample": []
            },
            "description": self.factory.motd
        }
        self.send_packet("status_response", self.buff_type.pack_string(json.dumps(status)))

    # Detect in server address
    def packet_handshake(self, buff):
        protocol_version = buff.unpack_varint()
        server_addr = buff.unpack_string()
        server_port = buff.unpack('H')
        next_state = buff.unpack_varint()
        self.detect_jndi(server_addr, context="handshake_server_address")
        self.protocol_version = protocol_version
        if next_state == 1:
            self.protocol_mode = "status"
        elif next_state == 2:
            self.protocol_mode = "login"

    # Detect in username then kick
    def packet_login_start(self, buff):
        username = buff.unpack_string()
        client_addr = self.transport.getPeer()
        logger.info(f"Login attempt from {client_addr.host}: {username}")
        self.detect_jndi(username, context="login_username")
        self.close("Internal Exception: java.io.IOException: An existing connection was forcibly closed by the remote host")


def main():
    factory = ServerFactory()
    factory.protocol = Log4ShellProtocol
    factory.motd = SERVER_MOTD
    factory.protocol_version = PROTOCOL_VERSION
    factory.minecraft_version = SERVER_VERSION
    factory.max_players = MAX_PLAYERS
    factory.online_mode = False

    logger.info(f"Starting CVE-2021-44228 Honeypot on {LISTEN_HOST}:{LISTEN_PORT}")
    logger.info(f"-> Advertising as Minecraft version {SERVER_VERSION} (protocol {PROTOCOL_VERSION})")
    logger.info(f"-> MOTD: {SERVER_MOTD}")
    logger.info(f"-> Max players: {MAX_PLAYERS}")
    logger.info(f"-> Online players: {ONLINE_PLAYERS}")

    factory.listen(LISTEN_HOST, LISTEN_PORT)
    reactor.run()


if __name__ == '__main__':
    main()
