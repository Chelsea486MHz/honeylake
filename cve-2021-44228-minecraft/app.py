import re
import logging
import os
import json
from datetime import datetime
from pathlib import Path

from twisted.internet import reactor
from quarry.net.server import ServerFactory, ServerProtocol
from quarry.net.protocol import ProtocolError

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

SAMPLES_DIR = Path('/samples')
SAMPLES_DIR.mkdir(exist_ok=True)

# Server configuration from environment variables
LISTEN_HOST = os.getenv('LISTEN_HOST', '0.0.0.0')
LISTEN_PORT = int(os.getenv('LISTEN_PORT', '25565'))
SERVER_MOTD = os.getenv('SERVER_MOTD', 'A Minecraft Server')
SERVER_VERSION = os.getenv('SERVER_VERSION', '1.18.0')
PROTOCOL_VERSION = int(os.getenv('PROTOCOL_VERSION', '757')) # https://minecraft.fandom.com/wiki/Protocol_version#Java_Edition_2
MAX_PLAYERS = int(os.getenv('MAX_PLAYERS', '20'))
ONLINE_PLAYERS = int(os.getenv('ONLINE_PLAYERS', '3'))
WHITELIST_ENABLED = os.getenv('WHITELIST_ENABLED', 'true').lower() == 'true'

# from https://github.com/back2root/log4shell-rex
JNDI_PATTERN = re.compile(r'(?im)(?:^|[\n]).*?(?:[\x24]|%(?:25%?)*24|\\u?0*(?:44|24))(?:[\x7b]|%(?:25%?)*7b|\\u?0*(?:7b|173))[^\n]*?((?:j|%(?:25%?)*(?:4a|6a)|\\u?0*(?:112|6a|4a|152))[^\n]*?(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))[^\n]*?(?:[\x3a]|%(?:25%?)*3a|\\u?0*(?:72|3a))[^\n]*?((?:l|%(?:25%?)*(?:4c|6c)|\\u?0*(?:154|114|6c|4c))[^\n]*?(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:a|%(?:25%?)*(?:41|61)|\\u?0*(?:101|61|41|141))[^\n]*?(?:p|%(?:25%?)*(?:50|70)|\\u?0*(?:70|50|160|120))(?:[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163)))?|(?:r|%(?:25%?)*(?:52|72)|\\u?0*(?:122|72|52|162))[^\n]*?(?:m|%(?:25%?)*(?:4d|6d)|\\u?0*(?:4d|155|115|6d))[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))|(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))|(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))|(?:[^\n]*?(?:[i\u0130\u0131]|%(?:25%?)*(?:49|69|C4%(?:25%?)*B0|C4%(?:25%?)*B1)|\\u?0*(?:111|69|49|151|130|460|131|461))){2}[^\n]*?(?:o|%(?:25%?)*(?:4f|6f)|\\u?0*(?:6f|4f|157|117))[^\n]*?(?:p|%(?:25%?)*(?:50|70)|\\u?0*(?:70|50|160|120))|(?:c|%(?:25%?)*(?:43|63)|\\u?0*(?:143|103|63|43))[^\n]*?(?:o|%(?:25%?)*(?:4f|6f)|\\u?0*(?:6f|4f|157|117))[^\n]*?(?:r|%(?:25%?)*(?:52|72)|\\u?0*(?:122|72|52|162))[^\n]*?(?:b|%(?:25%?)*(?:42|62)|\\u?0*(?:102|62|42|142))[^\n]*?(?:a|%(?:25%?)*(?:41|61)|\\u?0*(?:101|61|41|141))|(?:n|%(?:25%?)*(?:4e|6e)|\\u?0*(?:4e|156|116|6e))[^\n]*?(?:d|%(?:25%?)*(?:44|64)|\\u?0*(?:44|144|104|64))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))|(?:h|%(?:25%?)*(?:48|68)|\\u?0*(?:110|68|48|150))(?:[^\n]*?(?:t|%(?:25%?)*(?:54|74)|\\u?0*(?:124|74|54|164))){2}[^\n]*?(?:p|%(?:25%?)*(?:50|70)|\\u?0*(?:70|50|160|120))(?:[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163)))?)[^\n]*?(?:[\x3a]|%(?:25%?)*3a|\\u?0*(?:72|3a))|(?:b|%(?:25%?)*(?:42|62)|\\u?0*(?:102|62|42|142))[^\n]*?(?:a|%(?:25%?)*(?:41|61)|\\u?0*(?:101|61|41|141))[^\n]*?(?:[s\u017f]|%(?:25%?)*(?:53|73|C5%(?:25%?)*BF)|\\u?0*(?:17f|123|577|73|53|163))[^\n]*?(?:e|%(?:25%?)*(?:45|65)|\\u?0*(?:45|145|105|65))[^\n]*?(?:[\x3a]|%(?:25%?)*3a|\\u?0*(?:72|3a))(JH[s-v]|[\x2b\x2f-9A-Za-z][CSiy]R7|[\x2b\x2f-9A-Za-z]{2}[048AEIMQUYcgkosw]ke[\x2b\x2f-9w-z]))')


class Log4ShellProtocol(ServerProtocol):
    # In case clients attempt to join with a different version
    def protocol_error(self, err):
        logger.debug(f"Protocol error from {self.transport.getPeer().host}: {err}")
        self.close()

    def detect_jndi(self, text, context=""):
        if not isinstance(text, str):
            return

        match = JNDI_PATTERN.search(text)
        if match:
            timestamp = datetime.now().isoformat()
            client_addr = self.transport.getPeer()

            logger.warning(
                f"[JNDI LOOKUP DETECTED] Client: {client_addr.host}:{client_addr.port} | "
            )

            # Save to samples directory
            filename = f"log4shell_{timestamp.replace(':', '-')}_{client_addr.host}.txt"
            sample_path = SAMPLES_DIR / filename

            with open(sample_path, 'w') as f:
                f.write(f"Timestamp: {timestamp}\n")
                f.write(f"Client IP: {client_addr.host}\n")
                f.write(f"Client Port: {client_addr.port}\n")
                f.write(f"Context: {context}\n")
                f.write(f"Full Payload: {text}\n")
                f.write(f"Matched Pattern: {match.group(0)}\n")
                if match.groups():
                    f.write(f"Captured Groups: {match.groups()}\n")

            logger.info(f"Attack payload saved to {sample_path}")

    # Craft a fake response
    def packet_status_request(self, _buff):
        status = {
            "version": {
                "name": self.factory.minecraft_version,
                "protocol": self.factory.protocol_version
            },
            "players": {
                "max": self.factory.max_players,
                "online": ONLINE_PLAYERS,
                "sample": []
            },
            "description": self.factory.motd
        }
        self.send_packet("status_response", self.buff_type.pack_string(json.dumps(status)))

    # Detect in server address
    def packet_handshake(self, buff):
        protocol_version = buff.unpack_varint()
        server_addr = buff.unpack_string()
        server_port = buff.unpack('H')
        next_state = buff.unpack_varint()

        logger.info(f"Handshake from {self.transport.getPeer().host}: protocol={protocol_version}, server_addr={server_addr}, server_port={server_port}, next_state={next_state}")
        self.detect_jndi(server_addr, context="handshake_server_address")

        self.client_protocol_version = protocol_version

        # Handle status requests
        if next_state == 1:
            self.protocol_mode = "status"
            self.protocol_version = self.factory.protocol_version

        # Handle login attempts
        elif next_state == 2:
            if protocol_version != self.factory.protocol_version:
                logger.info(f"Rejecting incompatible protocol {protocol_version} (expected {self.factory.protocol_version})")
                if protocol_version < self.factory.protocol_version:
                    disconnect_msg = {"text": f"Outdated client! Please use {self.factory.minecraft_version}"}
                else:
                    disconnect_msg = {"text": f"Outdated server! I'm still on {self.factory.minecraft_version}"}

                self.send_packet("login_disconnect", self.buff_type.pack_chat(json.dumps(disconnect_msg)))
                self.close()
                return

            self.protocol_mode = "login"
            self.protocol_version = protocol_version

    # Detect in username then kick
    def packet_login_start(self, buff):
        username = buff.unpack_string()
        client_addr = self.transport.getPeer()
        logger.info(f"Login attempt from {client_addr.host}: username={username}")
        self.detect_jndi(username, context="login_username")

        # Kick with appropriate message based on whitelist configuration
        if WHITELIST_ENABLED:
            disconnect_msg = {"text": "You are not whitelisted on this server!"}
            self.send_packet("login_disconnect", self.buff_type.pack_chat(json.dumps(disconnect_msg)))
            self.close()
        else:
            # Fall back to IOException for non-whitelist mode
            self.close("Internal Exception: java.io.IOException: An existing connection was forcibly closed by the remote host")


def main():
    factory = ServerFactory()
    factory.protocol = Log4ShellProtocol
    factory.motd = SERVER_MOTD
    factory.protocol_version = PROTOCOL_VERSION
    factory.minecraft_version = SERVER_VERSION
    factory.max_players = MAX_PLAYERS
    factory.online_mode = False

    logger.info(f"Starting CVE-2021-44228 Honeypot on {LISTEN_HOST}:{LISTEN_PORT}")
    logger.info(f"-> Advertising as Minecraft version {SERVER_VERSION} (protocol {PROTOCOL_VERSION})")
    logger.info(f"-> MOTD: {SERVER_MOTD}")
    logger.info(f"-> Max players: {MAX_PLAYERS}")
    logger.info(f"-> Online players: {ONLINE_PLAYERS}")
    logger.info(f"-> Whitelist: {'Enabled' if WHITELIST_ENABLED else 'Disabled'}")

    factory.listen(LISTEN_HOST, LISTEN_PORT)
    reactor.run()


if __name__ == '__main__':
    main()
