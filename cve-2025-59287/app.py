import re
import logging
import os
import hashlib
import base64
import secrets
from datetime import datetime, timezone
from pathlib import Path

from flask import Flask, request, Response

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

app = Flask(__name__)

SAMPLES_DIR = Path('/samples')
SAMPLES_DIR.mkdir(exist_ok=True)

LISTEN_HOST = os.getenv('LISTEN_HOST', '0.0.0.0')
LISTEN_PORT = int(os.getenv('LISTEN_PORT', '8081'))
SERVER_NAME = os.getenv('SERVER_NAME', 'WSUS-SRV-01')
IIS_VERSION = os.getenv('IIS_VERSION', '10.0')
ASPNET_VERSION = os.getenv('ASPNET_VERSION', '4.0.30319')
SERVER_VERSION = os.getenv('SERVER_VERSION', '10.0.14393.0')
COOKIE_EXPIRATION = os.getenv('COOKIE_EXPIRATION', '2025-12-31T23:59:59Z')

# Detect de-serialization and suspicious strings
DESERIALIZATION_PATTERNS = [
    b'\x00\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00',
    b'System.Runtime.Serialization',
    b'BinaryFormatter',
    b'__type',
    b'TypeObject',
    b'ObjectStateFormatter',
    b'SoapFormatter',
    b'System.Windows.Data.ObjectDataProvider',
    b'System.Management.Automation',
    b'System.Diagnostics.Process',
    b'ProcessStartInfo',
    b'WindowsIdentity',
    b'System.Configuration.Install.AssemblyInstaller',
    b'U3lzdGVtLlJ1bnRpbWUuU2VyaWFsaXphdGlvbg==',
    b'QmluYXJ5Rm9ybWF0dGVy',
    b'AuthorizationCookie',
    b'EncryptionHelper',
    b'DecryptData',
    b'GetCookie',
]

SUSPICIOUS_STRINGS = [
    r'cmd\.exe',
    r'powershell',
    r'cmd /c',
    r'System\.Diagnostics\.Process',
    r'ProcessStartInfo',
    r'calc\.exe',
    r'whoami',
    r'net user',
    r'certutil',
    r'bitsadmin',
    r'Invoke-',
    r'DownloadString',
    r'DownloadFile',
    r'IEX\s*\(',
    r'[Ss]ystem\.[Mm]anagement\.[Aa]utomation',
]

SUSPICIOUS_STRING_PATTERN = re.compile('|'.join(SUSPICIOUS_STRINGS), re.IGNORECASE)


def parse_soap_request(body):
    if not body:
        return {}

    try:
        text_data = body.decode('utf-8', errors='replace')
    except:
        return {}

    soap_info = {}

    method_patterns = [
        r'<(\w+)\s+xmlns=',
        r'<(\w+)>',
        r'<m:(\w+)',
    ]

    for pattern in method_patterns:
        match = re.search(pattern, text_data)
        if match:
            method = match.group(1)
            if method not in ['soap', 'Envelope', 'Body', 'Header']:
                soap_info['method'] = method
                break

    if 'AuthorizationCookie' in text_data:
        soap_info['has_authorization_cookie'] = True
        cookie_data_match = re.search(r'<CookieData[^>]*>([^<]+)</CookieData>', text_data, re.IGNORECASE)
        if cookie_data_match:
            cookie_data = cookie_data_match.group(1).strip()
            soap_info['cookie_data'] = cookie_data
            soap_info['cookie_data_length'] = len(cookie_data)
        plugin_match = re.search(r'<PlugInId[^>]*>([^<]+)</PlugInId>', text_data, re.IGNORECASE)
        if plugin_match:
            soap_info['plugin_id'] = plugin_match.group(1).strip()

    return soap_info


def detect_exploit_patterns(data, client_ip, endpoint):
    if not data:
        return False

    detected_patterns = []

    for pattern in DESERIALIZATION_PATTERNS:
        if pattern in data:
            detected_patterns.append(pattern.decode('utf-8', errors='replace'))

    try:
        text_data = data.decode('utf-8', errors='replace')
        string_matches = SUSPICIOUS_STRING_PATTERN.findall(text_data)
        if string_matches:
            detected_patterns.extend(string_matches)
    except:
        pass

    if detected_patterns:
        logger.warning(
            f"[EXPLOIT DETECTED] Client: {client_ip} | Endpoint: {endpoint} | "
            f"Patterns: {', '.join(detected_patterns[:5])}"
        )
        return True

    return False


def save_sample(client_ip, endpoint, headers, body, soap_info=None):
    timestamp = datetime.now().isoformat()

    content_hash = hashlib.sha256(body).hexdigest()[:16]
    filename = f"wsus_{timestamp.replace(':', '-')}_{client_ip}_{content_hash}.txt"
    sample_path = SAMPLES_DIR / filename

    with open(sample_path, 'wb') as f:
        f.write(b"Metadata:\n")
        metadata = (
            f"Timestamp: {timestamp}\n"
            f"Client IP: {client_ip}\n"
            f"Endpoint: {endpoint}\n"
            f"Content-Length: {len(body)}\n"
            f"Content-Type: {headers.get('Content-Type', 'N/A')}\n"
            f"User-Agent: {headers.get('User-Agent', 'N/A')}\n"
            f"X-Decoy: {headers.get('X-Decoy', 'N/A')}\n"
        )
        f.write(metadata.encode('utf-8'))

        if soap_info:
            f.write(b"\nSOAP:\n")
            if 'method' in soap_info:
                f.write(f"SOAP Method: {soap_info['method']}\n".encode('utf-8'))
            if soap_info.get('has_authorization_cookie'):
                f.write(b"AuthorizationCookie: DETECTED (CVE-2025-59287 EXPLOIT ATTEMPT!)\n")
                if 'plugin_id' in soap_info:
                    f.write(f"  PlugInId: {soap_info['plugin_id']}\n".encode('utf-8'))
                if 'cookie_data' in soap_info:
                    f.write(f"  CookieData (first 100 chars): {soap_info['cookie_data']}\n".encode('utf-8'))
                    f.write(f"  CookieData Length: {soap_info['cookie_data_length']} bytes\n".encode('utf-8'))

        f.write(b"\nHeaders:\n")
        for key, value in headers.items():
            f.write(f"{key}: {value}\n".encode('utf-8'))

        f.write(b"\nBody:\n")
        f.write(body)

    logger.info(f"Attack payload saved to {sample_path}")
    return sample_path


# I put in extra effort to make this honeypot look realistic :D
def generate_soap_response(action="GetStatus"):
    responses = {
        "GetStatus": f"""<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <soap:Body>
    <GetStatusResponse xmlns="http://www.microsoft.com/SoftwareDistribution">
      <GetStatusResult>
        <Status>OK</Status>
        <ServerVersion>{SERVER_VERSION}</ServerVersion>
      </GetStatusResult>
    </GetStatusResponse>
  </soap:Body>
</soap:Envelope>""",

        "GetCookie": f"""<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <soap:Body>
    <GetCookieResponse xmlns="http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService">
      <GetCookieResult>
        <Expiration>{COOKIE_EXPIRATION}</Expiration>
        <PlugInId>SimpleTargeting</PlugInId>
        <CookieData>{base64.b64encode(secrets.token_bytes(128)).decode('utf-8')}</CookieData>
      </GetCookieResult>
    </GetCookieResponse>
  </soap:Body>
</soap:Envelope>""",

        "ReportInventory": """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ReportInventoryResponse xmlns="http://www.microsoft.com/SoftwareDistribution/ReportingWebService">
      <ReportInventoryResult>true</ReportInventoryResult>
    </ReportInventoryResponse>
  </soap:Body>
</soap:Envelope>""",

        "ServerError": """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Server</faultcode>
      <faultstring>An error occurred during processing</faultstring>
      <detail>
        <Error xmlns="http://www.microsoft.com/SoftwareDistribution">
          <ErrorCode>0x8024400E</ErrorCode>
          <Message>WU_E_PT_SOAP_SERVER: SOAP server error</Message>
        </Error>
      </detail>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>""",

        "InvalidRequest": """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Client</faultcode>
      <faultstring>Invalid SOAP request</faultstring>
      <detail>
        <Error xmlns="http://www.microsoft.com/SoftwareDistribution">
          <ErrorCode>0x8024400D</ErrorCode>
          <Message>WU_E_PT_SOAP_CLIENT: SOAP client error</Message>
        </Error>
      </detail>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>""",

        "DeserializationError": """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Server</faultcode>
      <faultstring>Error processing authorization data</faultstring>
      <detail>
        <Error xmlns="http://www.microsoft.com/SoftwareDistribution">
          <ErrorCode>0x80131501</ErrorCode>
          <Message>Deserialization failed</Message>
        </Error>
      </detail>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>"""
    }

    return responses.get(action, responses["GetStatus"])


@app.route('/report', methods=['POST', 'GET'])
def capture_request():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    endpoint = request.headers.get('X-Original-URI', request.path)

    logger.info(f"Request from {client_ip} to {endpoint}")

    headers = dict(request.headers)
    body = request.get_data()

    if request.method == 'GET' and '.asmx' in endpoint:
        logger.info(f"GET request to SOAP endpoint - returning InvalidRequest fault")
        return Response(
            generate_soap_response("InvalidRequest"),
            status=500,
            mimetype='text/xml; charset=utf-8',
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'X-Powered-By': 'ASP.NET',
                'X-AspNet-Version': ASPNET_VERSION,
            }
        )

    soap_info = parse_soap_request(body)
    if soap_info.get('method'):
        logger.info(f"SOAP Method: {soap_info['method']}")

    if soap_info.get('has_authorization_cookie'):
        logger.warning(
            f"[CVE-2025-59287 EXPLOIT DETECTED] Client: {client_ip} | "
            f"Endpoint: {endpoint} | AuthorizationCookie detected | "
            f"Method: {soap_info.get('method', 'Unknown')}"
        )

    is_exploit = detect_exploit_patterns(body, client_ip, endpoint)

    if is_exploit or soap_info.get('has_authorization_cookie') or len(body) > 0:
        save_sample(client_ip, endpoint, headers, body, soap_info)

    if len(body) == 0 and request.method == 'POST':
        logger.info(f"Empty POST request - returning InvalidRequest fault")
        return Response(
            generate_soap_response("InvalidRequest"),
            status=400,
            mimetype='text/xml; charset=utf-8',
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'X-Powered-By': 'ASP.NET',
                'X-AspNet-Version': ASPNET_VERSION,
            }
        )

    soap_action = headers.get('SOAPAction', '').strip('"')
    soap_method = soap_info.get('method', '')

    if 'GetCookie' in soap_action or 'GetCookie' in endpoint or 'GetCookie' in soap_method:
        response_body = generate_soap_response("GetCookie")
    elif 'ReportInventory' in soap_action or 'ReportInventory' in endpoint or 'ReportInventory' in soap_method:
        response_body = generate_soap_response("ReportInventory")
    else:
        response_body = generate_soap_response("GetStatus")

    return Response(
        response_body,
        mimetype='text/xml; charset=utf-8',
        headers={
            'Server': f'Microsoft-IIS/{IIS_VERSION}',
            'X-Powered-By': 'ASP.NET',
            'X-AspNet-Version': ASPNET_VERSION,
            'Cache-Control': 'private',
            'Date': datetime.now(timezone.utc).strftime('%a, %d %b %Y %H:%M:%S GMT')
        }
    )


@app.route('/', methods=['GET', 'POST'])
def root():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Root request from {client_ip}")

    return Response(
        generate_soap_response("GetStatus"),
        mimetype='text/xml',
        headers={'Server': f'Microsoft-IIS/{IIS_VERSION}'}
    )


if __name__ == '__main__':
    logger.info(f"Starting CVE-2025-59287 Honeypot on {LISTEN_HOST}:{LISTEN_PORT}")
    logger.info(f"-> Server Name: {SERVER_NAME}")

    app.run(
        host=LISTEN_HOST,
        port=LISTEN_PORT,
        debug=False
    )
