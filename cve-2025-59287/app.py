import re
import logging
import os
import hashlib
import base64
import secrets
from datetime import datetime, timezone
from pathlib import Path

from flask import Flask, request, Response

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

app = Flask(__name__)

SAMPLES_DIR = Path('/samples')
SAMPLES_DIR.mkdir(exist_ok=True)

LISTEN_HOST = os.getenv('LISTEN_HOST', '0.0.0.0')
LISTEN_PORT = int(os.getenv('LISTEN_PORT', '8081'))
SERVER_NAME = os.getenv('SERVER_NAME', 'WSUS-SRV-01')
IIS_VERSION = os.getenv('IIS_VERSION', '10.0')
ASPNET_VERSION = os.getenv('ASPNET_VERSION', '4.0.30319')
SERVER_VERSION = os.getenv('SERVER_VERSION', '10.0.14393.0')
COOKIE_EXPIRATION = os.getenv('COOKIE_EXPIRATION', '2025-12-31T23:59:59Z')

# Detect de-serialization and suspicious strings
DESERIALIZATION_PATTERNS = [
    b'\x00\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00',
    b'System.Runtime.Serialization',
    b'BinaryFormatter',
    b'__type',
    b'TypeObject',
    b'ObjectStateFormatter',
    b'SoapFormatter',
    b'System.Windows.Data.ObjectDataProvider',
    b'System.Management.Automation',
    b'System.Diagnostics.Process',
    b'ProcessStartInfo',
    b'WindowsIdentity',
    b'System.Configuration.Install.AssemblyInstaller',
    b'U3lzdGVtLlJ1bnRpbWUuU2VyaWFsaXphdGlvbg==',
    b'QmluYXJ5Rm9ybWF0dGVy',
    b'AuthorizationCookie',
    b'EncryptionHelper',
    b'DecryptData',
    b'GetCookie',
]

SUSPICIOUS_STRINGS = [
    r'cmd\.exe',
    r'powershell',
    r'cmd /c',
    r'System\.Diagnostics\.Process',
    r'ProcessStartInfo',
    r'calc\.exe',
    r'whoami',
    r'net user',
    r'certutil',
    r'bitsadmin',
    r'Invoke-',
    r'DownloadString',
    r'DownloadFile',
    r'IEX\s*\(',
    r'[Ss]ystem\.[Mm]anagement\.[Aa]utomation',
]

SUSPICIOUS_STRING_PATTERN = re.compile('|'.join(SUSPICIOUS_STRINGS), re.IGNORECASE)


def parse_soap_request(body):
    if not body:
        return {}

    try:
        text_data = body.decode('utf-8', errors='replace')
    except:
        return {}

    soap_info = {}

    method_patterns = [
        r'<(\w+)\s+xmlns=',
        r'<(\w+)>',
        r'<m:(\w+)',
    ]

    for pattern in method_patterns:
        match = re.search(pattern, text_data)
        if match:
            method = match.group(1)
            if method not in ['soap', 'Envelope', 'Body', 'Header']:
                soap_info['method'] = method
                break

    if 'AuthorizationCookie' in text_data:
        soap_info['has_authorization_cookie'] = True
        cookie_data_match = re.search(r'<CookieData[^>]*>([^<]+)</CookieData>', text_data, re.IGNORECASE)
        if cookie_data_match:
            cookie_data = cookie_data_match.group(1).strip()
            soap_info['cookie_data'] = cookie_data
            soap_info['cookie_data_length'] = len(cookie_data)
        plugin_match = re.search(r'<PlugInId[^>]*>([^<]+)</PlugInId>', text_data, re.IGNORECASE)
        if plugin_match:
            soap_info['plugin_id'] = plugin_match.group(1).strip()

    return soap_info


def detect_exploit_patterns(data, client_ip, endpoint):
    if not data:
        return False

    detected_patterns = []

    for pattern in DESERIALIZATION_PATTERNS:
        if pattern in data:
            detected_patterns.append(pattern.decode('utf-8', errors='replace'))

    try:
        text_data = data.decode('utf-8', errors='replace')
        string_matches = SUSPICIOUS_STRING_PATTERN.findall(text_data)
        if string_matches:
            detected_patterns.extend(string_matches)
    except:
        pass

    if detected_patterns:
        logger.warning(
            f"[EXPLOIT DETECTED] Client: {client_ip} | Endpoint: {endpoint} | "
            f"Patterns: {', '.join(detected_patterns[:5])}"
        )
        return True

    return False


def save_sample(client_ip, endpoint, headers, body, soap_info=None):
    timestamp = datetime.now().isoformat()

    content_hash = hashlib.sha256(body).hexdigest()[:16]
    filename = f"wsus_{timestamp.replace(':', '-')}_{client_ip}_{content_hash}.txt"
    sample_path = SAMPLES_DIR / filename

    with open(sample_path, 'wb') as f:
        f.write(b"Metadata:\n")
        metadata = (
            f"Timestamp: {timestamp}\n"
            f"Client IP: {client_ip}\n"
            f"Endpoint: {endpoint}\n"
            f"Content-Length: {len(body)}\n"
            f"Content-Type: {headers.get('Content-Type', 'N/A')}\n"
            f"User-Agent: {headers.get('User-Agent', 'N/A')}\n"
            f"X-Decoy: {headers.get('X-Decoy', 'N/A')}\n"
        )
        f.write(metadata.encode('utf-8'))

        if soap_info:
            f.write(b"\nSOAP:\n")
            if 'method' in soap_info:
                f.write(f"SOAP Method: {soap_info['method']}\n".encode('utf-8'))
            if soap_info.get('has_authorization_cookie'):
                f.write(b"AuthorizationCookie: DETECTED (CVE-2025-59287 EXPLOIT ATTEMPT!)\n")
                if 'plugin_id' in soap_info:
                    f.write(f"  PlugInId: {soap_info['plugin_id']}\n".encode('utf-8'))
                if 'cookie_data' in soap_info:
                    f.write(f"  CookieData (first 100 chars): {soap_info['cookie_data']}\n".encode('utf-8'))
                    f.write(f"  CookieData Length: {soap_info['cookie_data_length']} bytes\n".encode('utf-8'))

        f.write(b"\nHeaders:\n")
        for key, value in headers.items():
            f.write(f"{key}: {value}\n".encode('utf-8'))

        f.write(b"\nBody:\n")
        f.write(body)

    logger.info(f"Attack payload saved to {sample_path}")
    return sample_path


# I put in extra effort to make this honeypot look realistic :D
def generate_soap_response(action="GetStatus"):
    responses = {
        "GetStatus": f"""<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <soap:Body>
    <GetStatusResponse xmlns="http://www.microsoft.com/SoftwareDistribution">
      <GetStatusResult>
        <Status>OK</Status>
        <ServerVersion>{SERVER_VERSION}</ServerVersion>
      </GetStatusResult>
    </GetStatusResponse>
  </soap:Body>
</soap:Envelope>""",

        "GetCookie": f"""<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <soap:Body>
    <GetCookieResponse xmlns="http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService">
      <GetCookieResult>
        <Expiration>{COOKIE_EXPIRATION}</Expiration>
        <PlugInId>SimpleTargeting</PlugInId>
        <CookieData>{base64.b64encode(secrets.token_bytes(128)).decode('utf-8')}</CookieData>
      </GetCookieResult>
    </GetCookieResponse>
  </soap:Body>
</soap:Envelope>""",

        "ReportInventory": """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ReportInventoryResponse xmlns="http://www.microsoft.com/SoftwareDistribution/ReportingWebService">
      <ReportInventoryResult>true</ReportInventoryResult>
    </ReportInventoryResponse>
  </soap:Body>
</soap:Envelope>""",

        "ServerError": """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Server</faultcode>
      <faultstring>An error occurred during processing</faultstring>
      <detail>
        <Error xmlns="http://www.microsoft.com/SoftwareDistribution">
          <ErrorCode>0x8024400E</ErrorCode>
          <Message>WU_E_PT_SOAP_SERVER: SOAP server error</Message>
        </Error>
      </detail>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>""",

        "InvalidRequest": """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Client</faultcode>
      <faultstring>Invalid SOAP request</faultstring>
      <detail>
        <Error xmlns="http://www.microsoft.com/SoftwareDistribution">
          <ErrorCode>0x8024400D</ErrorCode>
          <Message>WU_E_PT_SOAP_CLIENT: SOAP client error</Message>
        </Error>
      </detail>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>""",

        "DeserializationError": """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Server</faultcode>
      <faultstring>Error processing authorization data</faultstring>
      <detail>
        <Error xmlns="http://www.microsoft.com/SoftwareDistribution">
          <ErrorCode>0x80131501</ErrorCode>
          <Message>Deserialization failed</Message>
        </Error>
      </detail>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>"""
    }

    return responses.get(action, responses["GetStatus"])


def generate_wsdl(service_name):
    client_wsdl = f"""<?xml version="1.0" encoding="utf-8"?>
<wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:tns="http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" targetNamespace="http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/">
  <wsdl:types>
    <s:schema elementFormDefault="qualified" targetNamespace="http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService">
      <s:element name="GetCookie">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="authorizationCookie" type="tns:AuthorizationCookie" />
            <s:element minOccurs="0" maxOccurs="1" name="plugInId" type="s:string" />
            <s:element minOccurs="1" maxOccurs="1" name="lastChange" type="s:dateTime" />
            <s:element minOccurs="1" maxOccurs="1" name="currentTime" type="s:dateTime" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="AuthorizationCookie">
        <s:sequence>
          <s:element minOccurs="0" maxOccurs="1" name="PlugInId" type="s:string" />
          <s:element minOccurs="0" maxOccurs="1" name="CookieData" type="s:base64Binary" />
          <s:element minOccurs="1" maxOccurs="1" name="Expiration" type="s:dateTime" />
        </s:sequence>
      </s:complexType>
      <s:element name="GetCookieResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="GetCookieResult" type="tns:AuthorizationCookie" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="RegisterComputer">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="cookie" type="tns:AuthorizationCookie" />
            <s:element minOccurs="0" maxOccurs="1" name="computerInfo" type="s:string" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="RegisterComputerResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="RegisterComputerResult" type="s:string" />
          </s:sequence>
        </s:complexType>
      </s:element>
    </s:schema>
  </wsdl:types>
  <wsdl:message name="GetCookieSoapIn">
    <wsdl:part name="parameters" element="tns:GetCookie" />
  </wsdl:message>
  <wsdl:message name="GetCookieSoapOut">
    <wsdl:part name="parameters" element="tns:GetCookieResponse" />
  </wsdl:message>
  <wsdl:message name="RegisterComputerSoapIn">
    <wsdl:part name="parameters" element="tns:RegisterComputer" />
  </wsdl:message>
  <wsdl:message name="RegisterComputerSoapOut">
    <wsdl:part name="parameters" element="tns:RegisterComputerResponse" />
  </wsdl:message>
  <wsdl:portType name="ClientWebServiceSoap">
    <wsdl:operation name="GetCookie">
      <wsdl:input message="tns:GetCookieSoapIn" />
      <wsdl:output message="tns:GetCookieSoapOut" />
    </wsdl:operation>
    <wsdl:operation name="RegisterComputer">
      <wsdl:input message="tns:RegisterComputerSoapIn" />
      <wsdl:output message="tns:RegisterComputerSoapOut" />
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="ClientWebServiceSoap" type="tns:ClientWebServiceSoap">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http" />
    <wsdl:operation name="GetCookie">
      <soap:operation soapAction="http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/GetCookie" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="RegisterComputer">
      <soap:operation soapAction="http://www.microsoft.com/SoftwareDistribution/Server/ClientWebService/RegisterComputer" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="ClientWebService">
    <wsdl:port name="ClientWebServiceSoap" binding="tns:ClientWebServiceSoap">
      <soap:address location="http://localhost:8530/ClientWebService/Client.asmx" />
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>"""

    reporting_wsdl = f"""<?xml version="1.0" encoding="utf-8"?>
<wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:tns="http://www.microsoft.com/SoftwareDistribution/ReportingWebService" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" targetNamespace="http://www.microsoft.com/SoftwareDistribution/ReportingWebService" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/">
  <wsdl:types>
    <s:schema elementFormDefault="qualified" targetNamespace="http://www.microsoft.com/SoftwareDistribution/ReportingWebService">
      <s:element name="ReportInventory">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="inventoryInfo" type="s:string" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="ReportInventoryResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="ReportInventoryResult" type="s:boolean" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="ReportEventBatch">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="events" type="s:string" />
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="ReportEventBatchResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="ReportEventBatchResult" type="s:boolean" />
          </s:sequence>
        </s:complexType>
      </s:element>
    </s:schema>
  </wsdl:types>
  <wsdl:message name="ReportInventorySoapIn">
    <wsdl:part name="parameters" element="tns:ReportInventory" />
  </wsdl:message>
  <wsdl:message name="ReportInventorySoapOut">
    <wsdl:part name="parameters" element="tns:ReportInventoryResponse" />
  </wsdl:message>
  <wsdl:message name="ReportEventBatchSoapIn">
    <wsdl:part name="parameters" element="tns:ReportEventBatch" />
  </wsdl:message>
  <wsdl:message name="ReportEventBatchSoapOut">
    <wsdl:part name="parameters" element="tns:ReportEventBatchResponse" />
  </wsdl:message>
  <wsdl:portType name="ReportingWebServiceSoap">
    <wsdl:operation name="ReportInventory">
      <wsdl:input message="tns:ReportInventorySoapIn" />
      <wsdl:output message="tns:ReportInventorySoapOut" />
    </wsdl:operation>
    <wsdl:operation name="ReportEventBatch">
      <wsdl:input message="tns:ReportEventBatchSoapIn" />
      <wsdl:output message="tns:ReportEventBatchSoapOut" />
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="ReportingWebServiceSoap" type="tns:ReportingWebServiceSoap">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http" />
    <wsdl:operation name="ReportInventory">
      <soap:operation soapAction="http://www.microsoft.com/SoftwareDistribution/ReportingWebService/ReportInventory" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="ReportEventBatch">
      <soap:operation soapAction="http://www.microsoft.com/SoftwareDistribution/ReportingWebService/ReportEventBatch" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="ReportingWebService">
    <wsdl:port name="ReportingWebServiceSoap" binding="tns:ReportingWebServiceSoap">
      <soap:address location="http://localhost:8530/ReportingWebService/ReportingWebService.asmx" />
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>"""

    simpleauth_wsdl = f"""<?xml version="1.0" encoding="utf-8"?>
<wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:tns="http://www.microsoft.com/SoftwareDistribution/SimpleAuthWebService" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" targetNamespace="http://www.microsoft.com/SoftwareDistribution/SimpleAuthWebService" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/">
  <wsdl:types>
    <s:schema elementFormDefault="qualified" targetNamespace="http://www.microsoft.com/SoftwareDistribution/SimpleAuthWebService">
      <s:element name="Ping">
        <s:complexType />
      </s:element>
      <s:element name="PingResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="1" maxOccurs="1" name="PingResult" type="s:boolean" />
          </s:sequence>
        </s:complexType>
      </s:element>
    </s:schema>
  </wsdl:types>
  <wsdl:message name="PingSoapIn">
    <wsdl:part name="parameters" element="tns:Ping" />
  </wsdl:message>
  <wsdl:message name="PingSoapOut">
    <wsdl:part name="parameters" element="tns:PingResponse" />
  </wsdl:message>
  <wsdl:portType name="SimpleAuthWebServiceSoap">
    <wsdl:operation name="Ping">
      <wsdl:input message="tns:PingSoapIn" />
      <wsdl:output message="tns:PingSoapOut" />
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="SimpleAuthWebServiceSoap" type="tns:SimpleAuthWebServiceSoap">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http" />
    <wsdl:operation name="Ping">
      <soap:operation soapAction="http://www.microsoft.com/SoftwareDistribution/SimpleAuthWebService/Ping" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="SimpleAuthWebService">
    <wsdl:port name="SimpleAuthWebServiceSoap" binding="tns:SimpleAuthWebServiceSoap">
      <soap:address location="http://localhost:8530/SimpleAuthWebService/SimpleAuth.asmx" />
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>"""

    apiremoting_wsdl = f"""<?xml version="1.0" encoding="utf-8"?>
<wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:tns="http://www.microsoft.com/SoftwareDistribution/ApiRemoting" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" targetNamespace="http://www.microsoft.com/SoftwareDistribution/ApiRemoting" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/">
  <wsdl:types>
    <s:schema elementFormDefault="qualified" targetNamespace="http://www.microsoft.com/SoftwareDistribution/ApiRemoting">
      <s:element name="GetAuthorizationCookie">
        <s:complexType />
      </s:element>
      <s:element name="GetAuthorizationCookieResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="GetAuthorizationCookieResult" type="s:string" />
          </s:sequence>
        </s:complexType>
      </s:element>
    </s:schema>
  </wsdl:types>
  <wsdl:message name="GetAuthorizationCookieSoapIn">
    <wsdl:part name="parameters" element="tns:GetAuthorizationCookie" />
  </wsdl:message>
  <wsdl:message name="GetAuthorizationCookieSoapOut">
    <wsdl:part name="parameters" element="tns:GetAuthorizationCookieResponse" />
  </wsdl:message>
  <wsdl:portType name="ApiRemotingWebServiceSoap">
    <wsdl:operation name="GetAuthorizationCookie">
      <wsdl:input message="tns:GetAuthorizationCookieSoapIn" />
      <wsdl:output message="tns:GetAuthorizationCookieSoapOut" />
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="ApiRemotingWebServiceSoap" type="tns:ApiRemotingWebServiceSoap">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http" />
    <wsdl:operation name="GetAuthorizationCookie">
      <soap:operation soapAction="http://www.microsoft.com/SoftwareDistribution/ApiRemoting/GetAuthorizationCookie" style="document" />
      <wsdl:input>
        <soap:body use="literal" />
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal" />
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="ApiRemotingWebService">
    <wsdl:port name="ApiRemotingWebServiceSoap" binding="tns:ApiRemotingWebServiceSoap">
      <soap:address location="http://localhost:8530/ApiRemoting30/WebService.asmx" />
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>"""

    wsdl_map = {
        'ClientWebService': client_wsdl,
        'ReportingWebService': reporting_wsdl,
        'SimpleAuthWebService': simpleauth_wsdl,
        'ApiRemotingWebService': apiremoting_wsdl,
    }

    return wsdl_map.get(service_name, client_wsdl)


def handle_soap_endpoint(endpoint_path):
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    endpoint = request.headers.get('X-Original-URI', endpoint_path)

    logger.info(f"Request from {client_ip} to {endpoint}")

    headers = dict(request.headers)
    body = request.get_data()

    if request.method == 'GET' and '.asmx' in endpoint and 'wsdl' in request.args:
        logger.info(f"WSDL request for {endpoint}")

        service_name = 'ClientWebService'
        if 'ReportingWebService' in endpoint or 'ReportWebService' in endpoint:
            service_name = 'ReportingWebService'
        elif 'SimpleAuth' in endpoint:
            service_name = 'SimpleAuthWebService'
        elif 'ApiRemoting' in endpoint:
            service_name = 'ApiRemotingWebService'
        elif 'Client' in endpoint or 'ClientWebService' in endpoint:
            service_name = 'ClientWebService'

        return Response(
            generate_wsdl(service_name),
            status=200,
            mimetype='text/xml; charset=utf-8',
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'X-Powered-By': 'ASP.NET',
                'X-AspNet-Version': ASPNET_VERSION,
                'Cache-Control': 'private',
            }
        )

    if request.method == 'GET' and '.asmx' in endpoint:
        logger.info(f"GET request to SOAP endpoint without ?wsdl - returning InvalidRequest fault")
        return Response(
            generate_soap_response("InvalidRequest"),
            status=500,
            mimetype='text/xml; charset=utf-8',
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'X-Powered-By': 'ASP.NET',
                'X-AspNet-Version': ASPNET_VERSION,
            }
        )

    soap_info = parse_soap_request(body)
    if soap_info.get('method'):
        logger.info(f"SOAP Method: {soap_info['method']}")

    if soap_info.get('has_authorization_cookie'):
        logger.warning(
            f"[CVE-2025-59287 EXPLOIT DETECTED] Client: {client_ip} | "
            f"Endpoint: {endpoint} | AuthorizationCookie detected | "
            f"Method: {soap_info.get('method', 'Unknown')}"
        )

    is_exploit = detect_exploit_patterns(body, client_ip, endpoint)

    if is_exploit or soap_info.get('has_authorization_cookie') or len(body) > 0:
        save_sample(client_ip, endpoint, headers, body, soap_info)

    if len(body) == 0 and request.method == 'POST':
        logger.info(f"Empty POST request - returning InvalidRequest fault")
        return Response(
            generate_soap_response("InvalidRequest"),
            status=400,
            mimetype='text/xml; charset=utf-8',
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'X-Powered-By': 'ASP.NET',
                'X-AspNet-Version': ASPNET_VERSION,
            }
        )

    soap_action = headers.get('SOAPAction', '').strip('"')
    soap_method = soap_info.get('method', '')

    if 'GetCookie' in soap_action or 'GetCookie' in endpoint or 'GetCookie' in soap_method:
        response_body = generate_soap_response("GetCookie")
    elif 'ReportInventory' in soap_action or 'ReportInventory' in endpoint or 'ReportInventory' in soap_method:
        response_body = generate_soap_response("ReportInventory")
    else:
        response_body = generate_soap_response("GetStatus")

    return Response(
        response_body,
        mimetype='text/xml; charset=utf-8',
        headers={
            'Server': f'Microsoft-IIS/{IIS_VERSION}',
            'X-Powered-By': 'ASP.NET',
            'X-AspNet-Version': ASPNET_VERSION,
            'Cache-Control': 'private',
            'Date': datetime.now(timezone.utc).strftime('%a, %d %b %Y %H:%M:%S GMT')
        }
    )


@app.route('/ClientWebService/Client.asmx', methods=['POST', 'GET'])
def clientwebservice_client():
    return handle_soap_endpoint('/ClientWebService/Client.asmx')


@app.route('/ClientWebService/ClientWebService.asmx', methods=['POST', 'GET'])
def clientwebservice():
    return handle_soap_endpoint('/ClientWebService/ClientWebService.asmx')


@app.route('/ReportingWebService/ReportingWebService.asmx', methods=['POST', 'GET'])
@app.route('/ReportWebService/ReportWebService.asmx', methods=['POST', 'GET'])
def reportingwebservice():
    endpoint = request.path
    return handle_soap_endpoint(endpoint)


@app.route('/SimpleAuthWebService/SimpleAuth.asmx', methods=['POST', 'GET'])
def simpleauthwebservice():
    return handle_soap_endpoint('/SimpleAuthWebService/SimpleAuth.asmx')


@app.route('/ApiRemoting30/WebService.asmx', methods=['POST', 'GET'])
def apiremoting():
    return handle_soap_endpoint('/ApiRemoting30/WebService.asmx')


@app.route('/report', methods=['POST', 'GET'])
def report_legacy():
    return handle_soap_endpoint('/report')


@app.route('/selfupdate/wuident.cab', methods=['GET', 'HEAD'])
def wuident_cab():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Request for wuident.cab from {client_ip}")

    # CAB file header, since I don't have the real file I can only emulate a simple one.
    dummy_cab = b'MSCF\x00\x00\x00\x00' + b'\x00' * 200

    if request.method == 'HEAD':
        return Response(
            status=200,
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'Content-Type': 'application/vnd.ms-cab-compressed',
                'Content-Length': str(len(dummy_cab)),
                'Last-Modified': 'Mon, 01 Oct 2025 12:00:00 GMT',
                'Accept-Ranges': 'bytes',
            }
        )

    return Response(
        dummy_cab,
        status=200,
        mimetype='application/vnd.ms-cab-compressed',
        headers={
            'Server': f'Microsoft-IIS/{IIS_VERSION}',
            'Last-Modified': 'Mon, 01 Oct 2025 12:00:00 GMT',
            'Accept-Ranges': 'bytes',
        }
    )


@app.route('/favicon.ico', methods=['GET'])
def favicon():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Request for favicon.ico from {client_ip}")

    # This is where I'd put my favicon. IF I HAD ONE !
    dummy_ico = (
        b'\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x00' + b'\x00' * 800
    )

    return Response(
        dummy_ico,
        status=200,
        mimetype='image/x-icon',
        headers={'Server': f'Microsoft-IIS/{IIS_VERSION}'}
    )


@app.route('/Content/', methods=['GET'])
@app.route('/Content/<path:subpath>', methods=['GET'])
def content_directory(subpath=''):
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Request for /Content/{subpath} from {client_ip}")

    return Response(
        '<!DOCTYPE html><html><head><title>404 Not Found</title></head>'
        '<body><h1>404 - File or directory not found.</h1>'
        '<p>The resource you are looking for might have been removed.</p></body></html>',
        status=404,
        mimetype='text/html',
        headers={'Server': f'Microsoft-IIS/{IIS_VERSION}'}
    )


@app.route('/Selfupdate/', methods=['GET'])
@app.route('/Selfupdate/<path:subpath>', methods=['GET', 'HEAD'])
def selfupdate_directory(subpath=''):
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Request for /Selfupdate/{subpath} from {client_ip}")

    return Response(
        '<!DOCTYPE html><html><head><title>404 Not Found</title></head>'
        '<body><h1>404 - File or directory not found.</h1></body></html>',
        status=404,
        mimetype='text/html',
        headers={'Server': f'Microsoft-IIS/{IIS_VERSION}'}
    )


@app.route('/', methods=['GET', 'POST'])
def root():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Root request from {client_ip}")

    return Response(
        generate_soap_response("GetStatus"),
        mimetype='text/xml',
        headers={'Server': f'Microsoft-IIS/{IIS_VERSION}'}
    )


if __name__ == '__main__':
    logger.info(f"Starting CVE-2025-59287 Honeypot on {LISTEN_HOST}:{LISTEN_PORT}")
    logger.info(f"-> Server Name: {SERVER_NAME}")

    app.run(
        host=LISTEN_HOST,
        port=LISTEN_PORT,
        debug=False
    )
