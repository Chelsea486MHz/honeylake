import re
import logging
import os
import hashlib
import base64
import secrets
from datetime import datetime, timezone
from pathlib import Path

from flask import Flask, request, Response, render_template_string

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

app = Flask(__name__)

SAMPLES_DIR = Path('/samples')
SAMPLES_DIR.mkdir(exist_ok=True)

LISTEN_HOST = os.getenv('LISTEN_HOST', '0.0.0.0')
LISTEN_PORT = int(os.getenv('LISTEN_PORT', '8081'))
SERVER_NAME = os.getenv('SERVER_NAME', 'WSUS-SRV-01')
IIS_VERSION = os.getenv('IIS_VERSION', '10.0')
ASPNET_VERSION = os.getenv('ASPNET_VERSION', '4.0.30319')
SERVER_VERSION = os.getenv('SERVER_VERSION', '10.0.14393.0')
COOKIE_EXPIRATION = os.getenv('COOKIE_EXPIRATION', '2025-12-31T23:59:59Z')

RESPONSES_DIR = Path(__file__).parent / 'responses'
SOAP_DIR = RESPONSES_DIR / 'soap'
WSDL_DIR = RESPONSES_DIR / 'wsdl'

def load_soap_response(template_name, **kwargs):
    template_path = SOAP_DIR / f'{template_name}.xml'
    with open(template_path, 'r') as f:
        template = f.read()
    return render_template_string(template, **kwargs)

def load_wsdl(service_name):
    wsdl_path = WSDL_DIR / f'{service_name}.wsdl'
    with open(wsdl_path, 'r') as f:
        return f.read()

# Detect de-serialization and suspicious strings
DESERIALIZATION_PATTERNS = [
    b'\x00\x01\x00\x00\x00\xff\xff\xff\xff\x01\x00\x00\x00',
    b'System.Runtime.Serialization',
    b'BinaryFormatter',
    b'__type',
    b'TypeObject',
    b'ObjectStateFormatter',
    b'SoapFormatter',
    b'System.Windows.Data.ObjectDataProvider',
    b'System.Management.Automation',
    b'System.Diagnostics.Process',
    b'ProcessStartInfo',
    b'WindowsIdentity',
    b'System.Configuration.Install.AssemblyInstaller',
    b'U3lzdGVtLlJ1bnRpbWUuU2VyaWFsaXphdGlvbg==',
    b'QmluYXJ5Rm9ybWF0dGVy',
    b'AuthorizationCookie',
    b'EncryptionHelper',
    b'DecryptData',
    b'GetCookie',
]

SUSPICIOUS_STRINGS = [
    r'cmd\.exe',
    r'powershell',
    r'cmd /c',
    r'System\.Diagnostics\.Process',
    r'ProcessStartInfo',
    r'calc\.exe',
    r'whoami',
    r'net user',
    r'certutil',
    r'bitsadmin',
    r'Invoke-',
    r'DownloadString',
    r'DownloadFile',
    r'IEX\s*\(',
    r'[Ss]ystem\.[Mm]anagement\.[Aa]utomation',
]

SUSPICIOUS_STRING_PATTERN = re.compile('|'.join(SUSPICIOUS_STRINGS), re.IGNORECASE)


def parse_soap_request(body):
    if not body:
        return {}

    try:
        text_data = body.decode('utf-8', errors='replace')
    except:
        return {}

    soap_info = {}

    method_patterns = [
        r'<(\w+)\s+xmlns=',
        r'<(\w+)>',
        r'<m:(\w+)',
    ]

    for pattern in method_patterns:
        match = re.search(pattern, text_data)
        if match:
            method = match.group(1)
            if method not in ['soap', 'Envelope', 'Body', 'Header']:
                soap_info['method'] = method
                break

    if 'AuthorizationCookie' in text_data:
        soap_info['has_authorization_cookie'] = True
        cookie_data_match = re.search(r'<CookieData[^>]*>([^<]+)</CookieData>', text_data, re.IGNORECASE)
        if cookie_data_match:
            cookie_data = cookie_data_match.group(1).strip()
            soap_info['cookie_data'] = cookie_data
            soap_info['cookie_data_length'] = len(cookie_data)
        plugin_match = re.search(r'<PlugInId[^>]*>([^<]+)</PlugInId>', text_data, re.IGNORECASE)
        if plugin_match:
            soap_info['plugin_id'] = plugin_match.group(1).strip()

    return soap_info


def detect_exploit_patterns(data, client_ip, endpoint):
    if not data:
        return False

    detected_patterns = []

    for pattern in DESERIALIZATION_PATTERNS:
        if pattern in data:
            detected_patterns.append(pattern.decode('utf-8', errors='replace'))

    try:
        text_data = data.decode('utf-8', errors='replace')
        string_matches = SUSPICIOUS_STRING_PATTERN.findall(text_data)
        if string_matches:
            detected_patterns.extend(string_matches)
    except:
        pass

    if detected_patterns:
        logger.warning(
            f"[EXPLOIT DETECTED] Client: {client_ip} | Endpoint: {endpoint} | "
            f"Patterns: {', '.join(detected_patterns[:5])}"
        )
        return True

    return False


def save_sample(client_ip, endpoint, headers, body, soap_info=None):
    timestamp = datetime.now().isoformat()

    content_hash = hashlib.sha256(body).hexdigest()[:16]
    filename = f"wsus_{timestamp.replace(':', '-')}_{client_ip}_{content_hash}.txt"
    sample_path = SAMPLES_DIR / filename

    with open(sample_path, 'wb') as f:
        f.write(b"Metadata:\n")
        metadata = (
            f"Timestamp: {timestamp}\n"
            f"Client IP: {client_ip}\n"
            f"Endpoint: {endpoint}\n"
            f"Content-Length: {len(body)}\n"
            f"Content-Type: {headers.get('Content-Type', 'N/A')}\n"
            f"User-Agent: {headers.get('User-Agent', 'N/A')}\n"
            f"X-Decoy: {headers.get('X-Decoy', 'N/A')}\n"
        )
        f.write(metadata.encode('utf-8'))

        if soap_info:
            f.write(b"\nSOAP:\n")
            if 'method' in soap_info:
                f.write(f"SOAP Method: {soap_info['method']}\n".encode('utf-8'))
            if soap_info.get('has_authorization_cookie'):
                f.write(b"AuthorizationCookie: DETECTED (CVE-2025-59287 EXPLOIT ATTEMPT!)\n")
                if 'plugin_id' in soap_info:
                    f.write(f"  PlugInId: {soap_info['plugin_id']}\n".encode('utf-8'))
                if 'cookie_data' in soap_info:
                    f.write(f"  CookieData (first 100 chars): {soap_info['cookie_data']}\n".encode('utf-8'))
                    f.write(f"  CookieData Length: {soap_info['cookie_data_length']} bytes\n".encode('utf-8'))

        f.write(b"\nHeaders:\n")
        for key, value in headers.items():
            f.write(f"{key}: {value}\n".encode('utf-8'))

        f.write(b"\nBody:\n")
        f.write(body)

    logger.info(f"Attack payload saved to {sample_path}")
    return sample_path


def generate_soap_response(action="GetStatus"):
    template_map = {
        "GetStatus": "get_status",
        "GetCookie": "get_cookie",
        "ReportInventory": "report_inventory",
        "ServerError": "server_error",
        "InvalidRequest": "invalid_request",
        "DeserializationError": "deserialization_error",
    }

    template_name = template_map.get(action, "get_status")

    kwargs = {
        'server_version': SERVER_VERSION,
        'cookie_expiration': COOKIE_EXPIRATION,
        'cookie_data': base64.b64encode(secrets.token_bytes(128)).decode('utf-8')
    }

    return load_soap_response(template_name, **kwargs)


def generate_wsdl(service_name):
    wsdl_map = {
        'ClientWebService': 'client',
        'ReportingWebService': 'reporting',
        'SimpleAuthWebService': 'simpleauth',
        'ApiRemotingWebService': 'apiremoting',
    }

    wsdl_file = wsdl_map.get(service_name, 'client')
    return load_wsdl(wsdl_file)


def handle_soap_endpoint(endpoint_path):
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    endpoint = request.headers.get('X-Original-URI', endpoint_path)

    logger.info(f"Request from {client_ip} to {endpoint}")

    headers = dict(request.headers)
    body = request.get_data()

    if request.method == 'GET' and '.asmx' in endpoint and 'wsdl' in request.args:
        logger.info(f"WSDL request for {endpoint}")

        service_name = 'ClientWebService'
        if 'ReportingWebService' in endpoint or 'ReportWebService' in endpoint:
            service_name = 'ReportingWebService'
        elif 'SimpleAuth' in endpoint:
            service_name = 'SimpleAuthWebService'
        elif 'ApiRemoting' in endpoint:
            service_name = 'ApiRemotingWebService'
        elif 'Client' in endpoint or 'ClientWebService' in endpoint:
            service_name = 'ClientWebService'

        return Response(
            generate_wsdl(service_name),
            status=200,
            mimetype='text/xml; charset=utf-8',
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'X-Powered-By': 'ASP.NET',
                'X-AspNet-Version': ASPNET_VERSION,
                'Cache-Control': 'private',
            }
        )

    if request.method == 'GET' and '.asmx' in endpoint:
        logger.info(f"GET request to SOAP endpoint without ?wsdl - returning InvalidRequest fault")
        return Response(
            generate_soap_response("InvalidRequest"),
            status=500,
            mimetype='text/xml; charset=utf-8',
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'X-Powered-By': 'ASP.NET',
                'X-AspNet-Version': ASPNET_VERSION,
            }
        )

    soap_info = parse_soap_request(body)
    if soap_info.get('method'):
        logger.info(f"SOAP Method: {soap_info['method']}")

    if soap_info.get('has_authorization_cookie'):
        logger.warning(
            f"[CVE-2025-59287 EXPLOIT DETECTED] Client: {client_ip} | "
            f"Endpoint: {endpoint} | AuthorizationCookie detected | "
            f"Method: {soap_info.get('method', 'Unknown')}"
        )

    is_exploit = detect_exploit_patterns(body, client_ip, endpoint)

    if is_exploit or soap_info.get('has_authorization_cookie') or len(body) > 0:
        save_sample(client_ip, endpoint, headers, body, soap_info)

    if len(body) == 0 and request.method == 'POST':
        logger.info(f"Empty POST request - returning InvalidRequest fault")
        return Response(
            generate_soap_response("InvalidRequest"),
            status=400,
            mimetype='text/xml; charset=utf-8',
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'X-Powered-By': 'ASP.NET',
                'X-AspNet-Version': ASPNET_VERSION,
            }
        )

    soap_action = headers.get('SOAPAction', '').strip('"')
    soap_method = soap_info.get('method', '')

    if 'GetCookie' in soap_action or 'GetCookie' in endpoint or 'GetCookie' in soap_method:
        response_body = generate_soap_response("GetCookie")
    elif 'ReportInventory' in soap_action or 'ReportInventory' in endpoint or 'ReportInventory' in soap_method:
        response_body = generate_soap_response("ReportInventory")
    else:
        response_body = generate_soap_response("GetStatus")

    return Response(
        response_body,
        mimetype='text/xml; charset=utf-8',
        headers={
            'Server': f'Microsoft-IIS/{IIS_VERSION}',
            'X-Powered-By': 'ASP.NET',
            'X-AspNet-Version': ASPNET_VERSION,
            'Cache-Control': 'private',
            'Date': datetime.now(timezone.utc).strftime('%a, %d %b %Y %H:%M:%S GMT')
        }
    )


@app.route('/ClientWebService/Client.asmx', methods=['POST', 'GET'])
def clientwebservice_client():
    return handle_soap_endpoint('/ClientWebService/Client.asmx')


@app.route('/ClientWebService/ClientWebService.asmx', methods=['POST', 'GET'])
def clientwebservice():
    return handle_soap_endpoint('/ClientWebService/ClientWebService.asmx')


@app.route('/ReportingWebService/ReportingWebService.asmx', methods=['POST', 'GET'])
@app.route('/ReportWebService/ReportWebService.asmx', methods=['POST', 'GET'])
def reportingwebservice():
    endpoint = request.path
    return handle_soap_endpoint(endpoint)


@app.route('/SimpleAuthWebService/SimpleAuth.asmx', methods=['POST', 'GET'])
def simpleauthwebservice():
    return handle_soap_endpoint('/SimpleAuthWebService/SimpleAuth.asmx')


@app.route('/ApiRemoting30/WebService.asmx', methods=['POST', 'GET'])
def apiremoting():
    return handle_soap_endpoint('/ApiRemoting30/WebService.asmx')


@app.route('/report', methods=['POST', 'GET'])
def report_legacy():
    return handle_soap_endpoint('/report')


@app.route('/selfupdate/wuident.cab', methods=['GET', 'HEAD'])
def wuident_cab():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Request for wuident.cab from {client_ip}")

    # CAB file header, since I don't have the real file I can only emulate a simple one.
    dummy_cab = b'MSCF\x00\x00\x00\x00' + b'\x00' * 200

    if request.method == 'HEAD':
        return Response(
            status=200,
            headers={
                'Server': f'Microsoft-IIS/{IIS_VERSION}',
                'Content-Type': 'application/vnd.ms-cab-compressed',
                'Content-Length': str(len(dummy_cab)),
                'Last-Modified': 'Mon, 01 Oct 2025 12:00:00 GMT',
                'Accept-Ranges': 'bytes',
            }
        )

    return Response(
        dummy_cab,
        status=200,
        mimetype='application/vnd.ms-cab-compressed',
        headers={
            'Server': f'Microsoft-IIS/{IIS_VERSION}',
            'Last-Modified': 'Mon, 01 Oct 2025 12:00:00 GMT',
            'Accept-Ranges': 'bytes',
        }
    )


@app.route('/favicon.ico', methods=['GET'])
def favicon():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Request for favicon.ico from {client_ip}")

    # This is where I'd put my favicon. IF I HAD ONE !
    dummy_ico = (
        b'\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x00' + b'\x00' * 800
    )

    return Response(
        dummy_ico,
        status=200,
        mimetype='image/x-icon',
        headers={'Server': f'Microsoft-IIS/{IIS_VERSION}'}
    )


@app.route('/Content/', methods=['GET'])
@app.route('/Content/<path:subpath>', methods=['GET'])
def content_directory(subpath=''):
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Request for /Content/{subpath} from {client_ip}")

    return Response(
        '<!DOCTYPE html><html><head><title>404 Not Found</title></head>'
        '<body><h1>404 - File or directory not found.</h1>'
        '<p>The resource you are looking for might have been removed.</p></body></html>',
        status=404,
        mimetype='text/html',
        headers={'Server': f'Microsoft-IIS/{IIS_VERSION}'}
    )


@app.route('/Selfupdate/', methods=['GET'])
@app.route('/Selfupdate/<path:subpath>', methods=['GET', 'HEAD'])
def selfupdate_directory(subpath=''):
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Request for /Selfupdate/{subpath} from {client_ip}")

    return Response(
        '<!DOCTYPE html><html><head><title>404 Not Found</title></head>'
        '<body><h1>404 - File or directory not found.</h1></body></html>',
        status=404,
        mimetype='text/html',
        headers={'Server': f'Microsoft-IIS/{IIS_VERSION}'}
    )


@app.route('/', methods=['GET', 'POST'])
def root():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Root request from {client_ip}")

    return Response(
        generate_soap_response("GetStatus"),
        mimetype='text/xml',
        headers={'Server': f'Microsoft-IIS/{IIS_VERSION}'}
    )


if __name__ == '__main__':
    logger.info(f"Starting CVE-2025-59287 Honeypot on {LISTEN_HOST}:{LISTEN_PORT}")
    logger.info(f"-> Server Name: {SERVER_NAME}")
    logger.info(f"-> IIS Version: {IIS_VERSION}")
    logger.info(f"-> Asp.NET Version: {ASPNET_VERSION}")
    logger.info(f"-> Cookie expiration: {COOKIE_EXPIRATION}")

    app.run(
        host=LISTEN_HOST,
        port=LISTEN_PORT,
        debug=False
    )
