import re
import logging
import os
import hashlib
import urllib.parse
from datetime import datetime
from pathlib import Path
from collections import defaultdict
from threading import Lock

from flask import Flask, request, Response, jsonify, render_template

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

app = Flask(__name__)

SAMPLES_DIR = Path('/samples')
SAMPLES_DIR.mkdir(exist_ok=True)

LISTEN_HOST = os.getenv('LISTEN_HOST', '0.0.0.0')
LISTEN_PORT = int(os.getenv('LISTEN_PORT', '8082'))
ROUTER_MODEL = os.getenv('ROUTER_MODEL', 'Archer AX21')
FIRMWARE_VERSION = os.getenv('FIRMWARE_VERSION', '1.1.0 Build 20211105')

# Track duplicate requests (exploitation requires sending request twice)
request_tracker = defaultdict(list)
tracker_lock = Lock()

# Command injection detection patterns
COMMAND_INJECTION_PATTERNS = [
    r'\$\(',
    r'`[^`]+`',
    r';(wget|curl|chmod|rm|cd|sh|bash|nc|cat|echo|kill)',
    r'\|(wget|curl|chmod|rm|sh|bash|nc|cat|mkfifo)',
    r'(wget|curl)\s+https?://',
    r'chmod\s+[0-7]{3}',
    r'mkfifo\s+/tmp',
    r'>/tmp/',
    r'\|/bin/(sh|bash)',
    r'nc\s+[\d\.]+\s+\d+',
    r'rm\s+-rf',
    r'\.\./',
    r'&(wget|curl|chmod|rm|sh|bash|nc)',
]

# Known malware script names
MALWARE_SCRIPTS = [
    r'tenda\.sh',
    r'bins\.sh',
    r'exec\.sh',
    r'jack\d*\.sh',
    r'\d+\.sh',
    r'[a-z]+\d+\.sh',
    r'shk\b',
    r'.*\.mips',
    r'.*\.arm',
    r'.*\.x86',
]

# Combine all patterns
ALL_PATTERNS = '|'.join(COMMAND_INJECTION_PATTERNS + MALWARE_SCRIPTS)
INJECTION_PATTERN = re.compile(ALL_PATTERNS, re.IGNORECASE)

# Suspicious commands that indicate exploitation
SUSPICIOUS_COMMANDS = [
    'wget', 'curl', 'nc', 'netcat', 'bash', 'sh', '/bin/sh', '/bin/bash',
    'chmod', 'rm', 'cd /tmp', 'mkfifo', 'cat', '>/tmp/', 'telnet'
]


def detect_command_injection(value, context=""):
    if not value:
        return None

    try:
        decoded_value = urllib.parse.unquote(value)
    except:
        decoded_value = value

    match = INJECTION_PATTERN.search(decoded_value)
    if match:
        return {
            'detected': True,
            'pattern': match.group(0),
            'decoded_value': decoded_value,
            'raw_value': value,
            'context': context
        }

    for cmd in SUSPICIOUS_COMMANDS:
        if cmd in decoded_value.lower():
            return {
                'detected': True,
                'pattern': cmd,
                'decoded_value': decoded_value,
                'raw_value': value,
                'context': context
            }

    return None


def extract_attack_metadata(country_value):
    metadata = {
        'download_urls': [],
        'commands': [],
        'malware_scripts': [],
        'ip_addresses': [],
    }

    if not country_value:
        return metadata

    try:
        decoded = urllib.parse.unquote(country_value)
    except:
        decoded = country_value

    url_pattern = re.compile(r'https?://[^\s\)]+')
    metadata['download_urls'] = url_pattern.findall(decoded)

    ip_pattern = re.compile(r'\b(?:\d{1,3}\.){3}\d{1,3}\b')
    metadata['ip_addresses'] = ip_pattern.findall(decoded)

    for pattern in MALWARE_SCRIPTS:
        matches = re.findall(pattern, decoded, re.IGNORECASE)
        metadata['malware_scripts'].extend(matches)

    cmd_pattern = re.compile(r'\b(wget|curl|chmod|bash|sh|nc|rm|cd|mkfifo|cat|echo)\b')
    metadata['commands'] = list(set(cmd_pattern.findall(decoded)))

    return metadata


def save_sample(client_ip, endpoint, headers, query_params, post_data, detection_info, request_number=1):
    timestamp = datetime.now().isoformat()

    country_value = query_params.get('country', post_data.get('country', ''))
    content_hash = hashlib.sha256(str(country_value).encode()).hexdigest()[:16]

    filename = f"tplink_{timestamp.replace(':', '-')}_{client_ip}_{content_hash}.txt"
    sample_path = SAMPLES_DIR / filename

    metadata = extract_attack_metadata(country_value)

    with open(sample_path, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\n")
        f.write("CVE-2023-1389 EXPLOITATION ATTEMPT DETECTED\n")
        f.write("=" * 80 + "\n\n")

        f.write(f"Timestamp: {timestamp}\n")
        f.write(f"Client IP: {client_ip}\n")
        f.write(f"Endpoint: {endpoint}\n")
        f.write(f"Request Number: {request_number} (Exploitation requires 2 requests)\n")
        f.write(f"Method: {request.method}\n")
        f.write(f"User-Agent: {headers.get('User-Agent', 'N/A')}\n\n")

        f.write("DETECTION INFO:\n")
        f.write("-" * 80 + "\n")
        f.write(f"Matched Pattern: {detection_info.get('pattern', 'N/A')}\n")
        f.write(f"Context: {detection_info.get('context', 'N/A')}\n\n")

        f.write("PAYLOAD ANALYSIS:\n")
        f.write("-" * 80 + "\n")
        f.write(f"Raw Country Value: {detection_info.get('raw_value', 'N/A')}\n")
        f.write(f"Decoded Country Value: {detection_info.get('decoded_value', 'N/A')}\n\n")

        if metadata['download_urls']:
            f.write(f"Download URLs: {', '.join(metadata['download_urls'])}\n")
        if metadata['ip_addresses']:
            f.write(f"IP Addresses: {', '.join(metadata['ip_addresses'])}\n")
        if metadata['malware_scripts']:
            f.write(f"Malware Scripts: {', '.join(metadata['malware_scripts'])}\n")
        if metadata['commands']:
            f.write(f"Commands: {', '.join(metadata['commands'])}\n")
        f.write("\n")

        f.write("QUERY PARAMETERS:\n")
        f.write("-" * 80 + "\n")
        for key, value in query_params.items():
            f.write(f"{key}: {value}\n")
        f.write("\n")

        if post_data:
            f.write("POST DATA:\n")
            f.write("-" * 80 + "\n")
            for key, value in post_data.items():
                f.write(f"{key}: {value}\n")
            f.write("\n")

        f.write("HTTP HEADERS:\n")
        f.write("-" * 80 + "\n")
        for key, value in headers.items():
            f.write(f"{key}: {value}\n")

    logger.info(f"Attack payload saved to {sample_path}")
    return sample_path


def track_request(client_ip, country_value):
    with tracker_lock:
        key = f"{client_ip}:{country_value}"
        now = datetime.now()

        request_tracker[key] = [
            ts for ts in request_tracker[key]
            if (now - ts).total_seconds() < 10
        ]

        request_tracker[key].append(now)
        request_number = len(request_tracker[key])

        return request_number


@app.route('/cgi-bin/luci/;stok=/locale', methods=['GET', 'POST'])
def vulnerable_locale_endpoint():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)

    query_params = dict(request.args)
    post_data = dict(request.form) if request.form else {}
    all_params = {**query_params, **post_data}

    form_param = all_params.get('form', '')
    operation = all_params.get('operation', '')
    country = all_params.get('country', '')

    logger.info(
        f"Request from {client_ip} to /cgi-bin/luci/;stok=/locale | "
        f"form={form_param} | operation={operation} | country={country[:50]}..."
    )

    if form_param == 'country' and operation == 'write' and country:
        detection = detect_command_injection(country, context="country_parameter")

        if detection:
            request_number = track_request(client_ip, country)

            logger.warning(
                f"[CVE-2023-1389 EXPLOIT DETECTED] Client: {client_ip} | "
                f"Request #{request_number} | Pattern: {detection['pattern']}"
            )

            save_sample(
                client_ip,
                '/cgi-bin/luci/;stok=/locale',
                dict(request.headers),
                query_params,
                post_data,
                detection,
                request_number
            )

            if request_number == 2:
                logger.warning(
                    f"[CVE-2023-1389 DOUBLE REQUEST] Client: {client_ip} | "
                    f"Second request detected - exploitation complete!"
                )

    return jsonify({
        "success": True,
        "data": {
            "country": "US"
        },
        "errorcode": 0
    })


@app.route('/webpages/login.html', methods=['GET'])
def login_page():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Login page request from {client_ip}")

    return render_template('login.html',
                         router_model=ROUTER_MODEL,
                         firmware_version=FIRMWARE_VERSION)


@app.route('/cgi-bin/luci/admin/<path:subpath>', methods=['GET', 'POST'])
def admin_endpoints(subpath):
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Admin endpoint request from {client_ip}: /cgi-bin/luci/admin/{subpath}")

    return jsonify({
        "success": False,
        "errorcode": 1,
        "data": {"msg": "Authentication required"}
    })


@app.route('/favicon.ico', methods=['GET'])
def favicon():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Favicon request from {client_ip}")

    from base64 import b64decode
    gif_data = b64decode('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')
    return Response(gif_data, mimetype='image/gif')


@app.route('/', methods=['GET'])
def root():
    client_ip = request.headers.get('X-Real-IP', request.remote_addr)
    logger.info(f"Root request from {client_ip}")

    return Response(
        '<html><head><meta http-equiv="refresh" content="0;url=/webpages/login.html"></head></html>',
        mimetype='text/html'
    )


@app.after_request
def add_router_headers(response):
    response.headers['Server'] = 'uhttpd'
    response.headers['Connection'] = 'Keep-Alive'
    response.headers['Keep-Alive'] = 'timeout=20'
    if response.mimetype == 'application/json':
        response.headers['Content-Type'] = 'application/json; charset=UTF-8'
    return response


if __name__ == '__main__':
    logger.info(f"Starting CVE-2023-1389 TP-Link {ROUTER_MODEL} Honeypot on {LISTEN_HOST}:{LISTEN_PORT}")
    logger.info(f"-> Router Model: {ROUTER_MODEL}")
    logger.info(f"-> Firmware Version: {FIRMWARE_VERSION}")

    app.run(
        host=LISTEN_HOST,
        port=LISTEN_PORT,
        debug=False
    )
