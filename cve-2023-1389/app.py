import re
import os
import urllib.parse
from pathlib import Path
from collections import defaultdict
from threading import Lock
from datetime import datetime

from flask import Flask, request, Response, jsonify, render_template

from honeylake_common import setup_logging, save_exploit_sample, get_env_int, get_env_str, get_real_client_ip

logger = setup_logging(__name__)

app = Flask(__name__)

SAMPLES_DIR = Path('/samples')

LISTEN_HOST = get_env_str('LISTEN_HOST', '0.0.0.0')
LISTEN_PORT = get_env_int('LISTEN_PORT', 8082)
ROUTER_MODEL = get_env_str('ROUTER_MODEL', 'Archer AX21')
FIRMWARE_VERSION = get_env_str('FIRMWARE_VERSION', '1.1.0 Build 20211105')

# Track duplicate requests (exploitation requires sending request twice)
request_tracker = defaultdict(list)
tracker_lock = Lock()

# Command injection detection patterns
COMMAND_INJECTION_PATTERNS = [
    r'\$\(',
    r'`[^`]+`',
    r';(wget|curl|chmod|rm|cd|sh|bash|nc|cat|echo|kill)',
    r'\|(wget|curl|chmod|rm|sh|bash|nc|cat|mkfifo)',
    r'(wget|curl)\s+https?://',
    r'chmod\s+[0-7]{3}',
    r'mkfifo\s+/tmp',
    r'>/tmp/',
    r'\|/bin/(sh|bash)',
    r'nc\s+[\d\.]+\s+\d+',
    r'rm\s+-rf',
    r'\.\./',
    r'&(wget|curl|chmod|rm|sh|bash|nc)',
]

# Known malware script names
MALWARE_SCRIPTS = [
    r'tenda\.sh',
    r'bins\.sh',
    r'exec\.sh',
    r'jack\d*\.sh',
    r'\d+\.sh',
    r'[a-z]+\d+\.sh',
    r'shk\b',
    r'.*\.mips',
    r'.*\.arm',
    r'.*\.x86',
]

# Combine all patterns
ALL_PATTERNS = '|'.join(COMMAND_INJECTION_PATTERNS + MALWARE_SCRIPTS)
INJECTION_PATTERN = re.compile(ALL_PATTERNS, re.IGNORECASE)

# Suspicious commands that indicate exploitation
SUSPICIOUS_COMMANDS = [
    'wget', 'curl', 'nc', 'netcat', 'bash', 'sh', '/bin/sh', '/bin/bash',
    'chmod', 'rm', 'cd /tmp', 'mkfifo', 'cat', '>/tmp/', 'telnet'
]


def detect_command_injection(value, context=""):
    if not value:
        return None

    try:
        decoded_value = urllib.parse.unquote(value)
    except:
        decoded_value = value

    match = INJECTION_PATTERN.search(decoded_value)
    if match:
        return {
            'detected': True,
            'pattern': match.group(0),
            'decoded_value': decoded_value,
            'raw_value': value,
            'context': context
        }

    for cmd in SUSPICIOUS_COMMANDS:
        if cmd in decoded_value.lower():
            return {
                'detected': True,
                'pattern': cmd,
                'decoded_value': decoded_value,
                'raw_value': value,
                'context': context
            }

    return None


def extract_attack_metadata(country_value):
    metadata = {
        'download_urls': [],
        'commands': [],
        'malware_scripts': [],
        'ip_addresses': [],
    }

    if not country_value:
        return metadata

    try:
        decoded = urllib.parse.unquote(country_value)
    except:
        decoded = country_value

    url_pattern = re.compile(r'https?://[^\s\)]+')
    metadata['download_urls'] = url_pattern.findall(decoded)

    ip_pattern = re.compile(r'\b(?:\d{1,3}\.){3}\d{1,3}\b')
    metadata['ip_addresses'] = ip_pattern.findall(decoded)

    for pattern in MALWARE_SCRIPTS:
        matches = re.findall(pattern, decoded, re.IGNORECASE)
        metadata['malware_scripts'].extend(matches)

    cmd_pattern = re.compile(r'\b(wget|curl|chmod|bash|sh|nc|rm|cd|mkfifo|cat|echo)\b')
    metadata['commands'] = list(set(cmd_pattern.findall(decoded)))

    return metadata


def save_sample(client_ip, endpoint, headers, query_params, post_data, detection_info, request_number=1):
    country_value = query_params.get('country', post_data.get('country', ''))
    metadata = extract_attack_metadata(country_value)

    extracted_payloads = []
    extracted_payloads.append(f"Matched Pattern: {detection_info.get('pattern', 'N/A')}")
    extracted_payloads.append(f"Raw: {detection_info.get('raw_value', 'N/A')}")
    extracted_payloads.append(f"Decoded: {detection_info.get('decoded_value', 'N/A')}")

    if metadata['download_urls']:
        extracted_payloads.extend([f"URL: {url}" for url in metadata['download_urls']])
    if metadata['malware_scripts']:
        extracted_payloads.extend([f"Script: {script}" for script in metadata['malware_scripts']])
    if metadata['commands']:
        extracted_payloads.extend([f"Command: {cmd}" for cmd in metadata['commands']])

    body_parts = []
    body_parts.append(f"Country Parameter: {country_value}\n")
    body_parts.append(f"\nQUERY PARAMETERS:\n")
    for key, value in query_params.items():
        body_parts.append(f"{key}: {value}\n")

    if post_data:
        body_parts.append(f"\nPOST DATA:\n")
        for key, value in post_data.items():
            body_parts.append(f"{key}: {value}\n")

    body = ''.join(body_parts).encode('utf-8')

    query_string = request.query_string.decode('utf-8') if request.query_string else None

    sample_path = save_exploit_sample(
        cve="CVE-2023-1389",
        client_ip=client_ip,
        headers=headers,
        body=body,
        samples_dir=SAMPLES_DIR,
        honeypot="tplink-archer-ax21",
        method=request.method,
        path=endpoint,
        query_string=query_string,
        protocol=request.environ.get('SERVER_PROTOCOL', 'HTTP/1.1'),
        extracted_payloads=extracted_payloads,
        attack_type="command_injection",
        confidence="high",
        context=detection_info.get('context', 'country_parameter'),
        request_number=request_number,
        download_urls=metadata['download_urls'],
        ip_addresses=metadata['ip_addresses'],
        malware_scripts=metadata['malware_scripts'],
        commands=metadata['commands']
    )

    logger.info(f"Attack payload saved to {sample_path}")
    return sample_path


def track_request(client_ip, country_value):
    with tracker_lock:
        key = f"{client_ip}:{country_value}"
        now = datetime.now()

        request_tracker[key] = [
            ts for ts in request_tracker[key]
            if (now - ts).total_seconds() < 10
        ]

        request_tracker[key].append(now)
        request_number = len(request_tracker[key])

        return request_number


@app.route('/cgi-bin/luci/;stok=/locale', methods=['GET', 'POST'])
def vulnerable_locale_endpoint():
    client_ip = get_real_client_ip(dict(request.headers), request.remote_addr)

    query_params = dict(request.args)
    post_data = dict(request.form) if request.form else {}
    all_params = {**query_params, **post_data}

    form_param = all_params.get('form', '')
    operation = all_params.get('operation', '')
    country = all_params.get('country', '')

    logger.info(
        f"Request from {client_ip} to /cgi-bin/luci/;stok=/locale | "
        f"form={form_param} | operation={operation} | country={country[:50]}..."
    )

    if form_param == 'country' and operation == 'write' and country:
        detection = detect_command_injection(country, context="country_parameter")

        if detection:
            request_number = track_request(client_ip, country)

            logger.warning(
                f"[CVE-2023-1389 EXPLOIT DETECTED] Client: {client_ip} | "
                f"Request #{request_number} | Pattern: {detection['pattern']}"
            )

            save_sample(
                client_ip,
                '/cgi-bin/luci/;stok=/locale',
                dict(request.headers),
                query_params,
                post_data,
                detection,
                request_number
            )

            if request_number == 2:
                logger.warning(
                    f"[CVE-2023-1389 DOUBLE REQUEST] Client: {client_ip} | "
                    f"Second request detected - exploitation complete!"
                )

    return jsonify({
        "success": True,
        "data": {
            "country": "US"
        },
        "errorcode": 0
    })


@app.route('/webpages/login.html', methods=['GET'])
def login_page():
    client_ip = get_real_client_ip(dict(request.headers), request.remote_addr)
    logger.info(f"Login page request from {client_ip}")

    return render_template('login.html',
                         router_model=ROUTER_MODEL,
                         firmware_version=FIRMWARE_VERSION)


@app.route('/cgi-bin/luci/admin/<path:subpath>', methods=['GET', 'POST'])
def admin_endpoints(subpath):
    client_ip = get_real_client_ip(dict(request.headers), request.remote_addr)
    logger.info(f"Admin endpoint request from {client_ip}: /cgi-bin/luci/admin/{subpath}")

    return jsonify({
        "success": False,
        "errorcode": 1,
        "data": {"msg": "Authentication required"}
    })


@app.route('/favicon.ico', methods=['GET'])
def favicon():
    client_ip = get_real_client_ip(dict(request.headers), request.remote_addr)
    logger.info(f"Favicon request from {client_ip}")

    from base64 import b64decode
    gif_data = b64decode('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')
    return Response(gif_data, mimetype='image/gif')


@app.route('/', methods=['GET'])
def root():
    client_ip = get_real_client_ip(dict(request.headers), request.remote_addr)
    logger.info(f"Root request from {client_ip}")

    return Response(
        '<html><head><meta http-equiv="refresh" content="0;url=/webpages/login.html"></head></html>',
        mimetype='text/html'
    )


@app.after_request
def add_router_headers(response):
    response.headers['Server'] = 'uhttpd'
    response.headers['Connection'] = 'Keep-Alive'
    response.headers['Keep-Alive'] = 'timeout=20'
    if response.mimetype == 'application/json':
        response.headers['Content-Type'] = 'application/json; charset=UTF-8'
    return response


if __name__ == '__main__':
    logger.info(f"Starting CVE-2023-1389 TP-Link {ROUTER_MODEL} Honeypot on {LISTEN_HOST}:{LISTEN_PORT}")
    logger.info(f"-> Router Model: {ROUTER_MODEL}")
    logger.info(f"-> Firmware Version: {FIRMWARE_VERSION}")

    app.run(
        host=LISTEN_HOST,
        port=LISTEN_PORT,
        debug=False
    )
